#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define HASH_SIZE 101

// -----------------------------
// Estruturas de dados
// -----------------------------

typedef struct Sala {
    char nome[50];
    char pista[100];
    struct Sala *esquerda;
    struct Sala *direita;
} Sala;

typedef struct PistaNode {
    char pista[100];
    struct PistaNode *esquerda;
    struct PistaNode *direita;
} PistaNode;

typedef struct HashNode {
    char pista[100];
    char suspeito[50];
    struct HashNode* proximo;
} HashNode;

// -----------------------------
// Funções para salas
// -----------------------------

Sala* criarSala(const char* nome, const char* pista) {
    Sala* nova = (Sala*)malloc(sizeof(Sala));
    strcpy(nova->nome, nome);
    strcpy(nova->pista, pista);
    nova->esquerda = NULL;
    nova->direita = NULL;
    return nova;
}

// -----------------------------
// Funções para BST de pistas
// -----------------------------

PistaNode* criarPistaNode(const char* pista) {
    PistaNode* novo = (PistaNode*)malloc(sizeof(PistaNode));
    strcpy(novo->pista, pista);
    novo->esquerda = NULL;
    novo->direita = NULL;
    return novo;
}

PistaNode* inserirPista(PistaNode* raiz, const char* pista) {
    if (!raiz) return criarPistaNode(pista);
    if (strcmp(pista, raiz->pista) < 0)
        raiz->esquerda = inserirPista(raiz->esquerda, pista);
    else if (strcmp(pista, raiz->pista) > 0)
        raiz->direita = inserirPista(raiz->direita, pista);
    return raiz;
}

void exibirPistas(PistaNode* raiz) {
    if (!raiz) return;
    exibirPistas(raiz->esquerda);
    printf("- %s\n", raiz->pista);
    exibirPistas(raiz->direita);
}

// -----------------------------
// Funções para tabela hash
// -----------------------------

unsigned int hash(const char* chave) {
    unsigned int h = 0;
    for (int i = 0; chave[i]; i++)
        h = (h * 31 + chave[i]) % HASH_SIZE;
    return h;
}

void inserirNaHash(HashNode* tabela[], const char* pista, const char* suspeito) {
    unsigned int h = hash(pista);
    HashNode* novo = (HashNode*)malloc(sizeof(HashNode));
    strcpy(novo->pista, pista);
    strcpy(novo->suspeito, suspeito);
    novo->proximo = tabela[h];
    tabela[h] = novo;
}

char* encontrarSuspeito(HashNode* tabela[], const char* pista) {
    unsigned int h = hash(pista);
    HashNode* atual = tabela[h];
    while (atual) {
        if (strcmp(atual->pista, pista) == 0)
            return atual->suspeito;
        atual = atual->proximo;
    }
    return NULL;
}

// -----------------------------
// Exploração da mansão
// -----------------------------

void explorarSalas(Sala* atual, PistaNode** arvorePistas, HashNode* tabela[]) {
    char escolha;
    while (atual != NULL) {
        printf("\nVocê está na sala: %s\n", atual->nome);

        if (strlen(atual->pista) > 0) {
            printf("Você encontrou uma pista: %s\n", atual->pista);
            *arvorePistas = inserirPista(*arvorePistas, atual->pista);
        }

        if (atual->esquerda == NULL && atual->direita == NULL) {
            printf("Não há mais caminhos nesta sala.\n");
            return;
        }

        printf("Escolha: (e) esquerda, (d) direita, (s) sair: ");
        scanf(" %c", &escolha);

        if (escolha == 'e' || escolha == 'E') {
            if (atual->esquerda != NULL)
                atual = atual->esquerda;
            else
                printf("Não há sala à esquerda!\n");
        } else if (escolha == 'd' || escolha == 'D') {
            if (atual->direita != NULL)
                atual = atual->direita;
            else
                printf("Não há sala à direita!\n");
        } else if (escolha == 's' || escolha == 'S') {
            printf("Exploração encerrada.\n");
            return;
        } else {
            printf("Opção inválida!\n");
        }
    }
}

// -----------------------------
// Função para julgamento
// -----------------------------

void verificarSuspeitoFinal(PistaNode* arvorePistas, HashNode* tabela[], const char* acusado) {
    int contador = 0;

    // Função auxiliar recursiva
    void contarPistas(PistaNode* raiz) {
        if (!raiz) return;
        contarPistas(raiz->esquerda);
        char* suspeito = encontrarSuspeito(tabela, raiz->pista);
        if (suspeito && strcmp(suspeito, acusado) == 0)
            contador++;
        contarPistas(raiz->direita);
    }

    contarPistas(arvorePistas);

    if (contador >= 2)
        printf("\nAcusação correta! %s é o culpado! (%d pistas)\n", acusado, contador);
    else
        printf("\nAcusação incorreta ou insuficiente. (%d pistas para %s)\n", contador, acusado);
}

// -----------------------------
// Main
// -----------------------------

int main() {
    // Criando salas da mansão
    Sala* hall = criarSala("Hall de Entrada", "Mapa da Mansão");
    Sala* cozinha = criarSala("Cozinha", "Chave da despensa");
    Sala* salaEstar = criarSala("Sala de Estar", "");
    Sala* biblioteca = criarSala("Biblioteca", "Diário antigo");
    Sala* jardim = criarSala("Jardim", "Pegadas misteriosas");
    Sala* quarto = criarSala("Quarto Secreto", "Carta enigmática");

    // Montando árvore da mansão
    hall->esquerda = cozinha;
    hall->direita = salaEstar;
    cozinha->esquerda = biblioteca;
    cozinha->direita = jardim;
    salaEstar->direita = quarto;

    // Inicializa BST de pistas e tabela hash
    PistaNode* arvorePistas = NULL;
    HashNode* tabela[HASH_SIZE] = {NULL};

    // Associa pistas a suspeitos
    inserirNaHash(tabela, "Mapa da Mansão", "Sr. Black");
    inserirNaHash(tabela, "Chave da despensa", "Sra. White");
    inserirNaHash(tabela, "Diário antigo", "Sr. Black");
    inserirNaHash(tabela, "Pegadas misteriosas", "Sr. Green");
    inserirNaHash(tabela, "Carta enigmática", "Sra. White");

    // Exploração interativa
    printf("Bem-vindo(a) ao Detective Quest - Capítulo Mestre!\n");
    explorarSalas(hall, &arvorePistas, tabela);

    // Exibir pistas coletadas
    printf("\nPistas coletadas:\n");
    exibirPistas(arvorePistas);

    // Acusação final
    char acusado[50];
    printf("\nQuem é o culpado? ");
    scanf("%s", acusado);

    verificarSuspeitoFinal(arvorePistas, tabela, acusado);

    // Liberando memória (simplificado)
    free(hall); free(cozinha); free(salaEstar);
    free(biblioteca); free(jardim); free(quarto);

    return 0;
}
